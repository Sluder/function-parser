INFO:root:R2 loaded arch: m7700
DEBUG:root:rst vector address found at: 0x93c1
INFO:root:Binary reset vector located at 0x93c1
INFO:root:Attempting to seek to reset vector...
INFO:root:R2 seeked to address 0x93c1
INFO:root:
INFO:root:Result of R2 call search: 
INFO:root:Found 0 potential candidates for grouping.
INFO:root:Found 0 groups of candidates.
INFO:root:R2 loaded arch: m7700
DEBUG:root:rst vector address found at: 0x93c1
INFO:root:Binary reset vector located at 0x93c1
INFO:root:Attempting to seek to reset vector...
INFO:root:R2 seeked to address 0x93c1
INFO:root:
INFO:root:Result of R2 call search: 
INFO:root:Found 0 potential candidates for grouping.
INFO:root:Found 0 groups of candidates.
INFO:root:R2 loaded arch: m7700
DEBUG:root:rst vector address found at: 0x93c1
INFO:root:Binary reset vector located at 0x93c1
INFO:root:Attempting to seek to reset vector...
INFO:root:R2 seeked to address 0x93c1
INFO:root:
INFO:root:Result of R2 call search: |Usage: /[!bf] [arg]Search stuff (see 'e??search' for options)
|Use io.va for searching in non virtual addressing spaces
| / foo\x00               search for string 'foo\0'
| /j foo\x00              search for string 'foo\0' (json output)
| /! ff                   search for first occurrence not matching, command modifier
| /!x 00                  inverse hexa search (find first byte != 0x00)
| /+ /bin/sh              construct the string with chunks
| //                      repeat last search
| /a jmp eax              assemble opcode and search its bytes
| /b                      search backwards, command modifier, followed by other command
| /B                      search recognized RBin headers
| /c jmp [esp]            search for asm code matching the given string
| /ce rsp,rbp             search for esil expressions matching
| /C[ar]                  search for crypto materials
| /d 101112               search for a deltified sequence of bytes
| /e /E.F/i               match regular expression
| /E esil-expr            offset matching given esil expressions %%= here
| /f                      search forwards, (command modifier)
| /F file [off] [sz]      search contents of file with offset and size
| /g[g] [from]            find all graph paths A to B (/gg follow jumps, see search.count and anal.depth)
| /h[t] [hash] [len]      find block matching this hash. See ph
| /i foo                  search for string 'foo' ignoring case
| /m magicfile            search for matching magic file (use blocksize)
| /M                      search for known filesystems and mount them automatically
| /o [n]                  show offset of n instructions backward
| /O [n]                  same as /o, but with a different fallback if anal cannot be used
| /p patternsize          search for pattern of given size
| /P patternsize          search similar blocks
| /r[erwx][?] sym.printf  analyze opcode reference an offset (/re for esil)
| /R [grepopcode]         search for matching ROP gadgets, semicolon-separated
| /v[1248] value          look for an `cfg.bigendian` 32bit value
| /V[1248] min max        look for an `cfg.bigendian` 32bit value in range
| /w foo                  search for wide string 'f\0o\0o\0'
| /wi foo                 search for wide string ignoring case 'f\0o\0o\0'
| /x ff..33               search for hex string ignoring some nibbles
| /x ff0033               search for hex string
| /x ff43:ffd0            search for hexpair with mask
| /z min max              search for strings of given size
DEBUG:root:Candidate: |Usage: /[!bf] [arg]Search stuff (see 'e??search' for options)
DEBUG:root:Candidate: |Use io.va for searching in non virtual addressing spaces
DEBUG:root:Candidate: | / foo\x00               search for string 'foo\0'
DEBUG:root:Candidate: | /j foo\x00              search for string 'foo\0' (json output)
DEBUG:root:Candidate: | /! ff                   search for first occurrence not matching, command modifier
DEBUG:root:Candidate: | /!x 00                  inverse hexa search (find first byte != 0x00)
DEBUG:root:Candidate: | /+ /bin/sh              construct the string with chunks
DEBUG:root:Candidate: | //                      repeat last search
DEBUG:root:Candidate: | /a jmp eax              assemble opcode and search its bytes
DEBUG:root:Candidate: | /b                      search backwards, command modifier, followed by other command
DEBUG:root:Candidate: | /B                      search recognized RBin headers
DEBUG:root:Candidate: | /c jmp [esp]            search for asm code matching the given string
DEBUG:root:Candidate: | /ce rsp,rbp             search for esil expressions matching
DEBUG:root:Candidate: | /C[ar]                  search for crypto materials
DEBUG:root:Candidate: | /d 101112               search for a deltified sequence of bytes
DEBUG:root:Candidate: | /e /E.F/i               match regular expression
DEBUG:root:Candidate: | /E esil-expr            offset matching given esil expressions %%= here
DEBUG:root:Candidate: | /f                      search forwards, (command modifier)
DEBUG:root:Candidate: | /F file [off] [sz]      search contents of file with offset and size
DEBUG:root:Candidate: | /g[g] [from]            find all graph paths A to B (/gg follow jumps, see search.count and anal.depth)
DEBUG:root:Candidate: | /h[t] [hash] [len]      find block matching this hash. See ph
DEBUG:root:Candidate: | /i foo                  search for string 'foo' ignoring case
DEBUG:root:Candidate: | /m magicfile            search for matching magic file (use blocksize)
DEBUG:root:Candidate: | /M                      search for known filesystems and mount them automatically
DEBUG:root:Candidate: | /o [n]                  show offset of n instructions backward
DEBUG:root:Candidate: | /O [n]                  same as /o, but with a different fallback if anal cannot be used
DEBUG:root:Candidate: | /p patternsize          search for pattern of given size
DEBUG:root:Candidate: | /P patternsize          search similar blocks
DEBUG:root:Candidate: | /r[erwx][?] sym.printf  analyze opcode reference an offset (/re for esil)
DEBUG:root:Candidate: | /R [grepopcode]         search for matching ROP gadgets, semicolon-separated
DEBUG:root:Candidate: | /v[1248] value          look for an `cfg.bigendian` 32bit value
DEBUG:root:Candidate: | /V[1248] min max        look for an `cfg.bigendian` 32bit value in range
DEBUG:root:Candidate: | /w foo                  search for wide string 'f\0o\0o\0'
DEBUG:root:Candidate: | /wi foo                 search for wide string ignoring case 'f\0o\0o\0'
DEBUG:root:Candidate: | /x ff..33               search for hex string ignoring some nibbles
DEBUG:root:Candidate: | /x ff0033               search for hex string
DEBUG:root:Candidate: | /x ff43:ffd0            search for hexpair with mask
DEBUG:root:Candidate: | /z min max              search for strings of given size
INFO:root:Found 0 potential candidates for grouping.
INFO:root:Found 0 groups of candidates.
